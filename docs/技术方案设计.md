# æ±‰å…œäºŒæ¬¡å¼€å‘æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡

## æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„
é‡‡ç”¨çŠ¶æ€é©±åŠ¨çš„å•é¡µé¢åº”ç”¨æ¶æ„ï¼ŒåŸºäºç°æœ‰Vue 3 + Composition APIæŠ€æœ¯æ ˆï¼Œé€šè¿‡çŠ¶æ€ç®¡ç†å®ç°æ¨¡å¼åˆ‡æ¢ï¼Œä¸å¼•å…¥é¢å¤–çš„è·¯ç”±ä¾èµ–ã€‚

```mermaid
graph TD
    A[App.vue] --> B{æ¸¸æˆæ¨¡å¼}
    B -->|æ¯æ—¥ä¸€é¢˜| C[ç°æœ‰é€»è¾‘]
    B -->|æ— å°½æ¨¡å¼| D[æ–°æ¨¡å¼é€»è¾‘]
    C --> E[Play.vue]
    D --> E
    E --> F[CharBlock.vue]
    E --> G[WordBlocks.vue]
    E --> H[åˆ†äº«ç»„ä»¶]
```

### çŠ¶æ€æ¶æ„
```typescript
// æ ¸å¿ƒçŠ¶æ€ç»“æ„
interface GameState {
  mode: 'daily' | 'endless'    // æ¸¸æˆæ¨¡å¼
  dailyState: DailyState        // æ¯æ—¥æ¨¡å¼çŠ¶æ€
  endlessState: EndlessState    // æ— å°½æ¨¡å¼çŠ¶æ€
}

interface DailyState {
  dayNo: number                 // æ—¥æœŸåºå·
  answer: Answer               // å½“æ—¥ç­”æ¡ˆ
  tries: string[]              // å°è¯•è®°å½•
  meta: TriesMeta              // å…ƒæ•°æ®
}

interface EndlessState {
  round: number                // å½“å‰è½®æ¬¡
  currentWord: string           // å½“å‰æˆè¯­
  tries: string[]              // å½“å‰è½®æ¬¡å°è¯•
  isFinished: boolean          // æ˜¯å¦å®Œæˆ
}
```

## æŠ€æœ¯é€‰å‹

### ä¿æŒç°æœ‰æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: Vue 3.2.45 + Composition API
- **æ„å»º**: Vite 4.x
- **æ ·å¼**: UnoCSS 0.47.x
- **çŠ¶æ€**: VueUse + reactive
- **ç±»å‹**: TypeScript 4.9.x
- **å›¾æ ‡**: Iconify

### æ–°å¢ä¾èµ–
æ— éœ€æ–°å¢ä¸»è¦ä¾èµ–ï¼Œä¿æŒé¡¹ç›®è½»é‡çº§ç‰¹æ€§ã€‚

## æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. æ¨¡å¼ç®¡ç†æ¨¡å— (mode.ts)
```typescript
import { ref, computed } from 'vue'

export type GameMode = 'daily' | 'endless'

// å½“å‰æ¸¸æˆæ¨¡å¼
const currentMode = ref<GameMode>('daily')

// æ¨¡å¼åˆ‡æ¢å‡½æ•°
export function switchMode(mode: GameMode) {
  currentMode.value = mode
}

// æ¨¡å¼åˆ¤æ–­computed
export const isDailyMode = computed(() => currentMode.value === 'daily')
export const isEndlessMode = computed(() => currentMode.value === 'endless')

// é‡ç½®æ¨¡å¼çŠ¶æ€
export function resetModeState(mode: GameMode) {
  if (mode === 'endless') {
    // é‡ç½®æ— å°½æ¨¡å¼çŠ¶æ€
    resetEndlessState()
  }
}
```

### 2. æ— å°½æ¨¡å¼å¼•æ“ (endless.ts)
```typescript
import { ref, computed } from 'vue'
import { getRandomIdiom } from './idioms'

// æ— å°½æ¨¡å¼çŠ¶æ€
const endlessRound = ref(1)
const currentWord = ref('')
const currentTries = ref<string[]>([])
const isRoundFinished = ref(false)

// åˆå§‹åŒ–æ— å°½æ¨¡å¼
export function initEndlessMode() {
  startNewRound()
}

// å¼€å§‹æ–°è½®æ¬¡
export function startNewRound() {
  currentWord.value = getRandomIdiom()
  currentTries.value = []
  isRoundFinished.value = false
  endlessRound.value++
}

// æ£€æŸ¥æ˜¯å¦å®Œæˆå½“å‰è½®æ¬¡
export function checkRoundComplete(word: string): boolean {
  return word === currentWord.value
}

// æ·»åŠ å°è¯•è®°å½•
export function addEndlessTry(word: string) {
  currentTries.value.push(word)
  if (checkRoundComplete(word)) {
    isRoundFinished.value = true
  }
}
```

### 3. éšæœºæˆè¯­ç”Ÿæˆå™¨ (randomIdiom.ts)
```typescript
import idiomsData from '../data/idioms.txt?raw'

let idiomsCache: string[] | null = null

// è·å–æ‰€æœ‰æˆè¯­
function getAllIdioms(): string[] {
  if (!idiomsCache) {
    idiomsCache = idiomsData
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length === 4) // åªä¿ç•™å››å­—æˆè¯­
  }
  return idiomsCache
}

// è·å–éšæœºæˆè¯­
export function getRandomIdiom(): string {
  const idioms = getAllIdioms()
  const randomIndex = Math.floor(Math.random() * idioms.length)
  return idioms[randomIndex]
}

// æ‰¹é‡è·å–éšæœºæˆè¯­ï¼ˆé¿å…é‡å¤ï¼‰
export function getRandomIdioms(count: number, exclude: string[] = []): string[] {
  const idioms = getAllIdioms()
  const available = idioms.filter(idiom => !exclude.includes(idiom))
  
  if (available.length < count) {
    throw new Error('å¯ç”¨çš„æˆè¯­æ•°é‡ä¸è¶³')
  }
  
  const result: string[] = []
  const used = new Set(exclude)
  
  while (result.length < count) {
    const randomIndex = Math.floor(Math.random() * available.length)
    const selected = available[randomIndex]
    
    if (!used.has(selected)) {
      result.push(selected)
      used.add(selected)
    }
  }
  
  return result
}
```

## ç»„ä»¶è®¾è®¡

### 1. GameModeSelector.vue - æ¨¡å¼é€‰æ‹©ç•Œé¢
```vue
<template>
  <div class="mode-selector">
    <div class="mode-cards">
      <div class="mode-card daily-mode" @click="selectMode('daily')">
        <div class="mode-icon">ğŸ“…</div>
        <h2>æ¯æ—¥ä¸€é¢˜</h2>
        <p>æ¯å¤©ä¸€ä¸ªæˆè¯­ï¼ŒæŒ‘æˆ˜ä½ çš„è¯æ±‡é‡</p>
        <div class="mode-features">
          <span>âœ“ æ¯æ—¥æ›´æ–°</span>
          <span>âœ“ å…¨çƒåŒæ­¥</span>
          <span>âœ“ å†å²è®°å½•</span>
        </div>
      </div>
      
      <div class="mode-card endless-mode" @click="selectMode('endless')">
        <div class="mode-icon">â™¾ï¸</div>
        <h2>æ— å°½æ¨¡å¼</h2>
        <p>è¿ç»­æŒ‘æˆ˜ï¼Œä¸æ–­çªç ´è‡ªæˆ‘</p>
        <div class="mode-features">
          <span>âœ“ æ— é™æŒ‘æˆ˜</span>
          <span>âœ“ å³æ—¶åé¦ˆ</span>
          <span>âœ“ è¿ç»­è®°å½•</span>
        </div>
      </div>
    </div>
    
    <div class="mode-stats" v-if="hasGameHistory">
      <h3>æ¸¸æˆç»Ÿè®¡</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-value">{{ totalGames }}</span>
          <span class="stat-label">æ€»æ¸¸æˆæ•°</span>
        </div>
        <div class="stat-item">
          <span class="stat-value">{{ winRate }}%</span>
          <span class="stat-label">èƒœç‡</span>
        </div>
        <div class="stat-item">
          <span class="stat-value">{{ currentStreak }}</span>
          <span class="stat-label">è¿ç»­å¤©æ•°</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { switchMode } from '~/logic/mode'
import { gamesCount, passedCount, currentStreak } from '~/storage'

const emit = defineEmits<{
  modeSelected: [mode: 'daily' | 'endless']
}>()

function selectMode(mode: 'daily' | 'endless') {
  switchMode(mode)
  emit('modeSelected', mode)
}

const hasGameHistory = computed(() => gamesCount.value > 0)
const totalGames = computed(() => gamesCount.value)
const winRate = computed(() => {
  if (gamesCount.value === 0) return 0
  return Math.round((passedCount.value / gamesCount.value) * 100)
})
</script>
```

### 2. App.vue ä¿®æ”¹æ–¹æ¡ˆ
```vue
<template>
  <main font-sans text="center gray-700 dark:gray-300" select-none>
    <!-- æ¨¡å¼é€‰æ‹©ç•Œé¢ -->
    <GameModeSelector 
      v-if="!modeSelected" 
      @mode-selected="onModeSelected" 
    />
    
    <!-- æ¸¸æˆç•Œé¢ -->
    <template v-else>
      <NotTodayBanner v-if="dayNo < daySince && isDailyMode" />
      <Navbar />
      <div p="4">
        <NoQuizToday v-if="!answer.word && isDailyMode" />
        <NoFuturePlay v-else-if="dayNo > daySince && !isDev && isDailyMode" />
        <NoPastPlay v-else-if="daySince - dayNo > DAYS_PLAY_BACK && !isDev && isDailyMode" />
        <Play v-else :mode="currentMode" @next-round="onNextRound" />
      </div>
      <ModalsLayer />
      <Confetti />
    </template>
  </main>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { currentMode, isDailyMode, isEndlessMode } from '~/logic/mode'
import { initEndlessMode } from '~/logic/endless'

const modeSelected = ref(false)

function onModeSelected(mode: 'daily' | 'endless') {
  modeSelected.value = true
  if (mode === 'endless') {
    initEndlessMode()
  }
}

function onNextRound() {
  // æ— å°½æ¨¡å¼å¼€å§‹æ–°è½®æ¬¡
  if (isEndlessMode.value) {
    // è§¦å‘Playç»„ä»¶é‡ç½®
  }
}
</script>
```

### 3. Play.vue ä¿®æ”¹æ–¹æ¡ˆ
```vue
<template>
  <!-- ç°æœ‰æ¨¡æ¿... -->
  
  <!-- æ— å°½æ¨¡å¼å®Œæˆç•Œé¢ -->
  <Transition name="fade-in">
    <div v-if="isEndlessMode && isFinished" class="endless-complete">
      <div class="complete-message">
        ğŸ‰ æ­å–œå®Œæˆç¬¬ {{ endlessRound }} è½®ï¼
      </div>
      <button class="next-round-btn" @click="startNextRound">
        å†æ¥ä¸€è¯
      </button>
    </div>
  </Transition>
</template>

<script setup lang="ts">
import { isEndlessMode } from '~/logic/mode'
import { startNewRound, endlessRound } from '~/logic/endless'

const props = defineProps<{
  mode: 'daily' | 'endless'
}>()

const emit = defineEmits<{
  nextRound: []
}>()

function startNextRound() {
  if (props.mode === 'endless') {
    startNewRound()
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    resetGameState()
    emit('nextRound')
  }
}

function resetGameState() {
  // é‡ç½®è¾“å…¥ã€å°è¯•è®°å½•ç­‰
  input.value = ''
  inputValue.value = ''
  tries.value = []
  meta.value = {}
}
</script>
```

## æ•°æ®æµè®¾è®¡

### çŠ¶æ€æµè½¬å›¾
```mermaid
stateDiagram-v2
    [*] --> ModeSelection
    ModeSelection --> DailyMode: é€‰æ‹©æ¯æ—¥ä¸€é¢˜
    ModeSelection --> EndlessMode: é€‰æ‹©æ— å°½æ¨¡å¼
    
    DailyMode --> Playing: å¼€å§‹æ¸¸æˆ
    Playing --> Success: çŒœå¯¹æˆè¯­
    Playing --> Failure: ç”¨å®Œæœºä¼š
    Success --> [*]
    Failure --> [*]
    
    EndlessMode --> EndlessPlaying: å¼€å§‹æ¸¸æˆ
    EndlessPlaying --> EndlessSuccess: çŒœå¯¹æˆè¯­
    EndlessPlaying --> EndlessFailure: ç”¨å®Œæœºä¼š
    EndlessSuccess --> NextRound: ç‚¹å‡»å†æ¥ä¸€è¯
    NextRound --> EndlessPlaying: æ–°è½®æ¬¡å¼€å§‹
    EndlessFailure --> NextRound: ç‚¹å‡»å†æ¥ä¸€è¯
```

### æ•°æ®åŒæ­¥ç­–ç•¥
1. **æ¯æ—¥æ¨¡å¼**: ä¿æŒç°æœ‰æ•°æ®åŒæ­¥é€»è¾‘
2. **æ— å°½æ¨¡å¼**: 
   - ä¸è®°å½•åˆ°å†å²ç»Ÿè®¡
   - åªä¿å­˜å½“å‰è½®æ¬¡çŠ¶æ€
   - æ–°è½®æ¬¡å®Œå…¨é‡ç½®çŠ¶æ€

## æ€§èƒ½ä¼˜åŒ–

### 1. æ‡’åŠ è½½ä¼˜åŒ–
```typescript
// æˆè¯­æ•°æ®æ‡’åŠ è½½
const idiomsPromise = import('../data/idioms.txt?raw').then(m => m.default)

export async function getRandomIdiom(): Promise<string> {
  const idiomsData = await idiomsPromise
  // å¤„ç†æ•°æ®...
}
```

### 2. ç»„ä»¶æ‡’åŠ è½½
```vue
<!-- æ¨¡å¼é€‰æ‹©ç»„ä»¶æ‡’åŠ è½½ -->
<script setup>
const GameModeSelector = defineAsyncComponent(() => 
  import('~/components/GameModeSelector.vue')
)
</script>
```

### 3. çŠ¶æ€ç¼“å­˜ç­–ç•¥
- æ¨¡å¼é€‰æ‹©çŠ¶æ€ï¼šsessionStorageç¼“å­˜
- æˆè¯­æ•°æ®ï¼šå†…å­˜ç¼“å­˜ + å¼‚æ­¥åŠ è½½
- æ¸¸æˆçŠ¶æ€ï¼šæŒ‰éœ€é‡ç½®ï¼Œé¿å…å†…å­˜æ³„æ¼

## é”™è¯¯å¤„ç†

### 1. æˆè¯­æ•°æ®åŠ è½½å¤±è´¥
```typescript
export async function getRandomIdiom(): Promise<string> {
  try {
    const idioms = await getAllIdioms()
    if (idioms.length === 0) {
      throw new Error('æˆè¯­æ•°æ®åŠ è½½å¤±è´¥')
    }
    // æ­£å¸¸é€»è¾‘...
  } catch (error) {
    console.error('è·å–éšæœºæˆè¯­å¤±è´¥:', error)
    // è¿”å›é»˜è®¤æˆè¯­æˆ–é”™è¯¯æç¤º
    return 'ä¸‡äº‹å¦‚æ„' // é»˜è®¤æˆè¯­
  }
}
```

### 2. æ¨¡å¼åˆ‡æ¢å¼‚å¸¸
```typescript
function selectMode(mode: GameMode) {
  try {
    switchMode(mode)
    if (mode === 'endless') {
      initEndlessMode()
    }
    emit('modeSelected', mode)
  } catch (error) {
    console.error('æ¨¡å¼åˆ‡æ¢å¤±è´¥:', error)
    // æ˜¾ç¤ºé”™è¯¯æç¤ºï¼Œä¿æŒå½“å‰æ¨¡å¼
    showToast('æ¨¡å¼åˆ‡æ¢å¤±è´¥ï¼Œè¯·é‡è¯•')
  }
}
```

## æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•
- æ¨¡å¼åˆ‡æ¢é€»è¾‘æµ‹è¯•
- éšæœºæˆè¯­ç”Ÿæˆå™¨æµ‹è¯•
- çŠ¶æ€ç®¡ç†æµ‹è¯•

### 2. é›†æˆæµ‹è¯•
- æ¨¡å¼é€‰æ‹©æµç¨‹æµ‹è¯•
- æ— å°½æ¨¡å¼å®Œæ•´æµç¨‹æµ‹è¯•
- æ•°æ®ä¸€è‡´æ€§æµ‹è¯•

### 3. ç”¨æˆ·ä½“éªŒæµ‹è¯•
- ç•Œé¢å“åº”æ€§æµ‹è¯•
- æ¨¡å¼åˆ‡æ¢æµç•…åº¦æµ‹è¯•
- é”™è¯¯å¤„ç†æµ‹è¯•

## éƒ¨ç½²æ–¹æ¡ˆ

### 1. æ„å»ºé…ç½®
ä¿æŒç°æœ‰Viteé…ç½®ï¼Œæ— éœ€ç‰¹æ®Šè°ƒæ•´ã€‚

### 2. ç¯å¢ƒå˜é‡
```bash
# å¯é€‰ï¼šæ·»åŠ åŠŸèƒ½å¼€å…³
VITE_ENABLE_ENDLESS_MODE=true
VITE_DISABLE_STRICT_MODE=true
```

### 3. æ€§èƒ½ç›‘æ§
- æ¨¡å¼åˆ‡æ¢æ—¶é—´ç›‘æ§
- æˆè¯­åŠ è½½æ—¶é—´ç›‘æ§
- é”™è¯¯ç‡ç›‘æ§

## æ‰©å±•æ€§è€ƒè™‘

### 1. æ–°æ¨¡å¼æ‰©å±•
çŠ¶æ€è®¾è®¡æ”¯æŒåç»­æ·»åŠ æ›´å¤šæ¸¸æˆæ¨¡å¼ï¼š
```typescript
type GameMode = 'daily' | 'endless' | 'timeattack' | 'multiplayer'
```

### 2. ä¸»é¢˜ç³»ç»Ÿ
æ¨¡å¼é€‰æ‹©ç•Œé¢æ”¯æŒä¸»é¢˜åŒ–ï¼š
```css
.mode-card {
  /* æ”¯æŒCSSå˜é‡ä¸»é¢˜ */
  --mode-primary: var(--c-primary);
  --mode-secondary: var(--c-secondary);
}
```

### 3. æ•°æ®ç»Ÿè®¡æ‰©å±•
æ— å°½æ¨¡å¼å¯æ‰©å±•ç»Ÿè®¡ç»´åº¦ï¼š
- è¿ç»­æ­£ç¡®è½®æ¬¡
- å¹³å‡ç”¨æ—¶è¶‹åŠ¿
- éš¾åº¦åˆ†å¸ƒç»Ÿè®¡

è¿™ä»½æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡ä¸ºäºŒæ¬¡å¼€å‘æä¾›äº†è¯¦ç»†çš„æŠ€æœ¯æŒ‡å¯¼å’Œå®ç°æ–¹æ¡ˆã€‚